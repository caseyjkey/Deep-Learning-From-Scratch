0. a. For my CSP, I define a variable for each switch, Xi... Xm, where Xi is the state of switch i. The domain of Xi is a subset of {0, 1} where (0 = off, 1 = on).
Constraints: 
 * We create one constraint for each light bulb j, where j ranges from 1 to n:
    * Each light bulb starts as off (0)
    * A light is on if it has been toggled an odd number of times
    * Each lightbulb is an element of Tj, and it is controlled by a set of switches Xj
        * Scope: {Xj | i is an element of Tj} 
        * Expression: sum({j : i is an element of Tj}) Xj % 2 == 1

b. i. 2: (0,1,0) and (1,0,1)
ii. 1. backtrack({})
2. backtrack({X1: 0})
3. backtrack({X1: 0, X3: 0})
try X2.
    * try 0: X1 xor X2 is 0 
    * try 1: x1 xor x2 is 1, x2 xor x3 is 1.
4. backtrack({X1: 0, X3: 0, X2: 1})
    solution: (0, 1, 0)
5. backtrack({X1: 0, X3: 1})
try X2.
    * try 0: x1 xor x2 is 0
    * try 1: x1 xor x2 is 1, x2 xor x3 is 0.
6. backtrack({X1: 1})
7. backtrack({X1: 1, X3: 0})
try X2.
    * try 0: x1 xor x2 is 1
    * try 1: x1 xor x2 is 0, x2 xor x3 is 0.
8.backtrack({X1: 1, X3: 1})
try X2.
    * try 0: x1 xor x2 is 1, x2 xor x3 is 1.
9. backtrack({X1: 1, X3: 1, X2: 0})
    solution: (1, 0, 1)

iii. 1. backtrack({})
2. backtrack({X1: 0})
X2 {1}
3. backtrack({X1: 0, X3: 0})
X2 {1}
4. backtrack({X1: 0, X3: 0, X2: 1})
    solution: (0, 1, 0)
5. backtrack({X1: 1})
X2 {0}
6. backtrack({X1: 1, X3: 1})
X2 {0}
7. backtrack({X1: 1, X3: 1, X2: 0})
    solution: (1, 0, 1)

1. 